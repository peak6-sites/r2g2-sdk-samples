"""
This is an example of how to use the R2G2 API to upload files interact with an Assistant, written in Python
This example assumes the `R2G2_TOKEN` environment variable is set to a valid token, generated using the
`r2g2 auth print-access-token` command.
"""

import os
import time
from typing import List

import requests

ASSISTANT_SERVER_URI = "https://api-proxy-prod.prod.gcp.minisme.ai"


def main():
    # Retrieve an Assistant by ID so that we can find the ID of the Store
    assistant = get_assistant("ASSISTANT_4D8QET2CGDPZ284V1DRQQ9F3R1")

    # Upload a file to the Store
    with open("testdata/file.txt", "rb") as f:
        upload_files(assistant["storeId"], [f])

    # Execute the Assistant and wait for it to complete
    run = run_assistant(assistant["id"], "Write me a story.")
    wait_for_run_completion(run["id"])

    # Retrieve the messages generated by the Assistant and print them to stdout
    print(get_response_messages(run["threadId"], run["id"]))


def get_assistant(assistant_id: str) -> dict:
    """
    Retrieve an Assistant by ID.

    :param assistant_id: The ID of the Assistant to retrieve.
    :returns: An Assistant object.
    """
    response = requests.post(
        f"{ASSISTANT_SERVER_URI}/ai.assistants.v0.Assistants/GetAssistant",
        headers={"Authorization": f"Bearer {os.environ.get("R2G2_TOKEN")}"},
        json={"id": assistant_id},
    )
    response.raise_for_status()
    return response.json()


def upload_files(store_id: str, files: List) -> None:
    """
    Upload files to a Store.

    :param store_id: The ID of the Store to upload files to
    :param files: A list of file-like objects to upload
    :return:
    """
    body = {"storeId": store_id}
    for file in files:
        body["filename"] = file.name

        # Generate a new upload URL for the file
        response = requests.post(
            f"{ASSISTANT_SERVER_URI}/ai.Stores/UploadFileUnary",
            headers={"Authorization": f"Bearer {os.environ.get("R2G2_TOKEN")}"},
            json=body,
        )
        response.raise_for_status()
        upload_files_response = response.json()

        # Set the headers for the upload
        # The server will return the set of REQUIRED headers that must be provided on the PUT request to the upload URL
        upload_headers = {}
        for (k, v) in upload_files_response["headers"].items():
            upload_headers[k] = v

        # Perform the upload by issuing an HTTP PUT request to the upload URL
        # The file contents are sent as the body of the request
        response = requests.put(
            upload_files_response["url"],
            headers=upload_headers,
            data=file.read(),
        )
        response.raise_for_status()


def run_assistant(assistant_id: str, query: str) -> dict:
    """
    Run an Assistant with a query.

    :param assistant_id: The ID of the Assistant to run
    :param query: The user query to run the Assistant with
    :returns: A Run object
    """
    response = requests.post(
        f"{ASSISTANT_SERVER_URI}/ai.assistants.v0.Assistants/CreateThreadAndRun",
        headers={"Authorization": f"Bearer {os.environ.get("R2G2_TOKEN")}"},
        json={"assistant_id": assistant_id, "thread": {"messages": [{"role": "USER", "content": query}]}},
    )
    response.raise_for_status()
    return response.json()


def wait_for_run_completion(run_id: str) -> None:
    """
    Waits for a Run to complete by polling the server until the Run is in a terminal state.

    :param run_id: The ID of the Run to wait for
    :return:
    """
    while True:
        # Retrieve the current state of the Run
        response = requests.post(
            f"{ASSISTANT_SERVER_URI}/ai.assistants.v0.Assistants/GetRun",
            headers={"Authorization": f"Bearer {os.environ.get("R2G2_TOKEN")}"},
            json={"id": run_id},
        )
        response.raise_for_status()
        run = response.json()

        state = run["state"]
        if state == "SUCCEEDED":
            # The Run has completed successfully
            return None
        elif state == "FAILED":
            # The Run has failed
            raise Exception(f"run failed: {run["failureReason"]}")
        elif state == "TOOL_RESPONSE_REQUIRED":
            # The Run is waiting for a response from a tool
            raise RuntimeError("tool response required")
        else:
            # The Run is either PENDING or RUNNING, so sleep for a bit and check again
            time.sleep(0.1)


def get_response_messages(thread_id: str, run_id: str) -> str:
    """
    Retrieve the messages generated by a Run.

    :param thread_id: The ID of the Thread to retrieve messages from
    :param run_id: The ID of the Run that generated the messages
    :return: A string containing the concatenated text of the messages
    """
    # Retrieve the messages generated by the Run
    response = requests.post(
        f"{ASSISTANT_SERVER_URI}/ai.assistants.v0.Assistants/ListMessages",
        headers={"Authorization": f"Bearer {os.environ.get("R2G2_TOKEN")}"},
        json={"threadId": thread_id, "runId": run_id},
    )
    response.raise_for_status()
    list_messages = response.json()

    # Iterate the messages and concatenate the text of each message
    messages = list_messages["messages"]
    text = ""
    for messages in messages:
        content = messages["content"]
        for content in content:
            text_content = content.get("text", None)
            if not text_content:
                continue

            text += text_content + "\n"

    return text


if __name__ == "__main__":
    main()
